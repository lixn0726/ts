## 时间轮组件



对于高复用性的框架，需要使用层级时间轮，对比单层的时间轮在于，需要维护更多层次的任务。

比如，单层时间轮只需要维护pointer、round即可；层级时间轮需要维护一层level，并且如果不同层级之间的tickDuration不一致，那么也会增加复杂度。



#### 设想

时间轮设计为 JobList[]

jobList存放 jobListEntry

jobListEntry存放真正的job，并维护level、round等延时数据



jobList底层是一个集合，我的设想是借助一个类似于Redis ZSet的集合，根据round对jobList里的节点进行排序，那么在指针挪动的时候，不需要将jobList的job全部遍历，而是拿到第一个不符合条件的job之后即可退出。

##### 方案

TreeSet也许无法满足需求。虽然有first()，但是只能拿到头节点。或许自己改造一下可以。



#### 知识点

时间轮是一种高性能、低消耗的数据结构。适用于非准实时、延迟的短平快任务。Netty就应用时间轮来进行心跳检测。

用于延时任务的实现。通过时间轮+提醒实现延迟。

时间轮内部实现基本为数组，尽量确保大小为2的倍数，主要是为了可以进行位运算提升效率。参考HashMap#tableSizeFor(int cap)方法：

```java
static final int tableSizeFor(int cap) {
  int n = cap - 1;
  n |= n >>> 1;
  n |= n >>> 1;
  n |= n >>> 1;
  n |= n >>> 1;
  n |= n >>> 1;
  return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? : MAXIMUM_CAPACITY : n + 1;
}
```

以输入cap = 31为例。

```
1. int n = 31 - 1 = 30

2. n >>> 1 = 算数右移1位 = 15 = 00001111
3. 所以 n |= (n >>> 1) = 30 |= 15 = 00011110 |= 00001111 = 00011111 = 31

4. n >>> 2 = 算数右移2位 = 7 = 00000111
5. 所以 n |= (n >>> 2) = 31 |= 7 = 00011111 |= 00000111 = 31

6. n >>> 4 = 算数右移4位 = 1 = 00000001
7. 所以 n |= (n >>> 4) = 31 |= 1 = 00011111 |= 00000001 = 31

8. n >>> 8 = 算数右移8位 = 0 = 00000000
9. 所以 n |= (n >>> 8) = 31 |= 0 = 00011111 |= 00000000 = 31

10. n >>> 16同理

11. 可以看出tableSizeFor就是通过多次位运算来获得 2的N次方 - 1的数res。然后返回res + 1即是偶数。
```



## 运行流程及架构





## 现有的定时任务组件

Quartz：任务存储方式包括：

1. RAM Job Store
2. JDBC